# 总结


## 学习方法

* 不要死磕
* 五毒神掌（敢于放手、敢于死记硬背代码），5是指每一个题写5遍
* 不懒于看高手代码
* 5分钟想不出来，就直接看题解或者高票代码，用五毒神掌变成自己的东西。

## 数据结构和方法总览

* 学习方法3步走：
1. chunk it up
2. delibrate practicting
3. feebback

### chunk it up
* 把知识切成碎片
* 数据结构结构
* 所有算法数据结构的基石
```
if-else, switch-branch
for, while loop -> iteration
递归Recursion（Divide&Conquer，Backtrace）
```

### deliberate practing

## 刷题技巧

1. 先沟通好，明白题目到底要什么
2. 想出所有可能的解法（比较不同解法的时空复杂度）
3. 多写
4. 写test cases

## 训练环境设置、变成技巧和code style

* 刷完leetcode题后一定要看国际站的先进代码:

* 一些快捷键要记住
> 跳转行头、行为  
> 跳转单词  
> 往后删除代码  
> 选整行  
* 搜VScode top tips

*  自定向下的编程方式:
> 先解决上层的主干逻辑  


## 时空复杂度

* 一般来说， 如果有数组，数组的长度就是空间复杂度
> 一维数组 O(n)  
> 二维数组 O(n^2)  
* 递归则是递归最大的深度
* 如果两者都有，则是递归和数组的最大值

## 数组、链表、跳表的基本实现和特性：

###  数组

* 数组是内存中存储的连续的地址
* 数组的访问是O(1)
* 数组的插入/删除是O(n)
* 插入的时候要考虑有没有超过容量

### linked list
* 在添加和删除的操作比较胖频繁的时候
* 每一个item是一个class，有两个值，一个是value，另一个是next。

> 单向链表  
> 循环链表  
> 双向链表  

* 链表的增加和删除是O(1)
* 访问是O(n)
 
### 跳表

* 跳表是用来取代平衡树和二分查找的
* 一维的数据结构要加速，经常采用的方式就是升维，一维变二维


## 栈、队列的实现与特性

* 栈
> 先进后出  
> 添加、删除都是O(1)  
> 查询为O(n)  

* 队列
> 先进先出  
> 添加、删除都是O(1)  
> 查询为O(n)  

### 双端队列

* 两头都可进可出
* 添加、删除都是O(1)
* 查询为O(n)


## 优先队列

* 按照优先级先出
* 插入是O(1)
* 取出是O(logN)


## 哈希表、映射、集合

* 多数情况下，查询、添加、删除都是O(1)
* 某种不好的情况（哈希函数选得不好）下会退化成链表
* 哈希表就是可以把存储的值映射到一个位置（index）
* 如果发生了哈希碰撞，可以在同一个index拉出一张链表
* 如果哈希算法好，避免了碰撞，就不用拉链，查询就是O(1), 如果拉链的情况很多，就会退化到O(n)












#52-算法训练营