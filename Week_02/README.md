# 总结

##  二叉树

* linked lists是特殊化的Tree
* Tree是特殊化的图

### 二叉树的遍历

1. 前序（Pre-order）： 根-左-右
2. 中序（In-order）：左-根-右
3. 后序（Post-order）：左-右-根

* 一般使用递归遍历

## 二叉搜索树

* 左子树上所有结点的值均小于它的根节点的值
* 右子树上所有结点的值均大于它根节点的值
* 以此类推，左、右子树也分别为二叉搜索树
* 二叉搜索树的查询、插入、删除都是log(n)

* 两种遍历的方案：
1. 递归（即让程序自动帮你维护一个栈）
2. 自己维护一个栈

## 堆和二叉堆

* 可以迅速找到一堆树中的最大或最小值的数据结构
* find-max: (1)
* delete-max: O(logN)
* insert(create): O(logN) or O(1)
* 如要优先拿出任务级最高的任务，这种数据结构就更好用

*  二叉堆最容易实现，但是速度最慢
* 完全二叉树就是除了最后的节点不满，其他都是满的

### 二叉堆的实现细节

1. 二叉堆一般都通过“数组”实现
2. 假设“第一个元素”在数组中的索引为0的话，则父节点和子节点的位置关系如下：
* 索引为i的左孩子的索引是（2*i + 1） 
* 索引为i的有孩子的索引是（2*i + 2）
* 索引为i的父节点的索引是floor((i-1)/2)

### 插入操作

1. 新元素一律先查到堆的尾部
2. 一次向上调整整个堆的结构（一直到根即可）

### 删除操作

1. 将堆尾元素替换到顶部（即对顶被替代删除掉）
2. 依次从根部向下调整整个堆的结构（一直到堆尾即可）

## 递归

* 数学归纳法：
> n=1 n=2 是成立的，且能推倒出n+1和n的关系  

* 递归的写法：
1. 递归总结条件
2. 处理当前层的逻辑
3. 下探到下一层
4. 清理当前层

* 其他要考虑的点：
1. 传入的参数
2. 全局变量
























#52-算法训练营